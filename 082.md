Quick Chocolate Swift

high

# Users funds can be stolen via a malicious pool contract
## Summary

## Vulnerability Detail
The Router contract serves as a higher-level contract intended for use by the majority of users and encompasses the implementation of the exactInput functions. Each exactInput calls `_swapExactInputInternal`. The key argument of the function is the path which contains pool address
```solidity
params.amountIn = _swapExactInputInternal(
        params.amountIn,
        hasMultiplePools ? address(this) : params.recipient, 
        0,
        SwapCallbackData({path: params.path.getFirstPool(), source: source})
);
```
The problem is that there is no pool address verification. This leaves room for potential exploitation. An attacker could deceive a user into invoking 'exactInput' with a malevolent contract posing as a legitimate pool, thereby compromising the user's assets. Despite the requirement for user transaction authorization, this attack vector carries a relatively low level of difficulty for several reasons:
1. The 'path' parameter is consistently generated by frontend applications, with users relying on these applications to correctly populate the 'path' field. For instance, Uniswap employs a sophisticated router that constructs optimized paths. It is anticipated that the audited project will also employ a similar router, and users will routinely utilize the paths generated by this router without scrutinizing them.
2. Additionally, the 'path' parameter is encoded as a byte array, making it challenging for users to decipher and verify directly within their wallet interfaces.
3. The attack is executed through the official Router contract, which can lead users to falsely believe they are secure when initiating a transaction from a malicious frontend application. Users might add the official Router contract to their list of trusted contracts (a feature supported by MetaMask), further blurring the line between legitimate and malicious transactions

## Impact
Users can lose funds during swapping

## Code Snippet
https://github.com/sherlock-audit/2023-07-kyber-swap/blob/main/ks-elastic-sc/contracts/periphery/Router.sol#L103-L108

https://github.com/sherlock-audit/2023-07-kyber-swap/blob/main/ks-elastic-sc/contracts/periphery/Router.sol#L172

## Tool used

Manual Review

## Recommendation
Always check that pools being called in the Router were created through the Factory
```solidity
require(factory.isFactoryPool(IPool(pool)), "Unsupported pool");
```